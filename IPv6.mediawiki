== Low Level ==

`IReactorTCP.connectTCP` will be extended with these (backwards compatible) changes:

  1. An IPv6 address literal, optionally(?) with a percent-embedded scopeid will be allowed as the value of the `host` parameter
  1. The `bindAddress` parameter will accept 4-tuples.  The first element is an address like the above, the other three are port number, flow info, and scope id.
    1. (Maybe `bindAddress` values shouldn't be tuples but should be nice structured objects instead)
  1. If `host` is IPv6, bindAddress must be as well, and vice versa.

`IReactorTCP.listenTCP` will be extended with these (backwards compatible) changes:

  1. `interface` will accept an ipv6 address literal value like the one described above
  1. The default listen address will still be INADDR_ANY (this is a non-change; pass "::" if you want IPv6 servers, or see the high level APIs)

`IReactorUDP.listenUDP` will be extended in an analogous way to `IReactorTCP.listenTCP`

`IUDPTransport.write` and `IUDPTransport.connect`:

  1. For UDP ports listening on ipv6 addresses only, will be extended to accept a value for `addr` which is a 4-tuple like the one described above.

`IMulticastTransport.joinGroup` and `leaveGroup` are similarly extended.  `setOutgoingInterface`, who knows?

For the APIs mentioned above which can accept hostnames instead of IP address
literals, no IPv6 name resolution (hosts file, dns, etc) will be attempted when
a hostname is supplied.

== High Level ==

Introduce `HostnameClientEndpoint`.  This endpoint takes a hostname and a port
number.  The hostname is resolved using `getaddrinfo` (#4362) and a connection
attempted to each address (perhaps serially, perhaps concurrently, perhaps
concurrently with a staggered start) and stops after a connection attempt
succeeds.  Internally this will find an IPv4 or IPv6 address to try and then
pass it to `IReactorTCP.connectTCP`.

Introduce `AllLocalInterfacesServerEndpoint`.  This endpoint binds to all local
interfaces on some port and returns an aggregate `IListeningPort` implementation
that can deal with the multiple underlying ports.
