= EDNS Plan =

[[PageOutline(2-4)]]


== Overview ==

Twisted includes a comprehensive set of DNS components, collectively
known as twisted Names.
  * wiki:TwistedNames

This is a plan for the development of EDNS(0) and DNSSEC support in Twisted
Names.

 * New public APIs will be as narrow as possible, to minimise future backwards
   compatibility complications.

 * Zero changes to existing public APIs. (if possible)

 * Existing classes will be wrapped where appropriate and in other cases, shared
   functionality will be extracted and re-factored for reuse in new classes.

 * Composition, not inheritance
   * http://pyvideo.org/video/1684/the-end-of-object-inheritance-the-beginning-of
   * #6382

 * Old sub-optimal APIs will be deprecated and eventually removed after the
   introduction new EDNS and DNSSEC APIs.
   * #1216



== Existing Implementations ==

Re-use of existing Python DNS libraries (or C libraries with Python bindings)
will be considered according to the following criteria:
 1. MIT compatible licence
 2. Actively maintained
 3. Full test coverage

However the potential time savings from reusing an existing library will be
weighed against the overhead of introducing an additional Twisted install
dependency.

Examples of existing libraries / implementations:
 * http://www.dnspython.org/
 * https://www.nlnetlabs.nl/projects/ldns/index.html
 * http://trac.secdev.org/scapy/ticket/84

Other sources:
 * https://github.com/aetrion/dnstest
 * https://github.com/aetrion/erl-dns
 * https://github.com/habnabit/spiral
 * https://bazaar.launchpad.net/~ubuntu-branches/ubuntu/saucy/bind9/saucy/view/head:/lib/dns/message.c
 * http://doc.powerdns.com/html/recursor-design-and-engineering.html#idp9245952



== Milestones ==

Before we can fully support DNSSEC, we need to first implement EDNS(0) support.

Some DNSSEC APIS (lookup methods, record types) can be implemented in parallel
and will be immediately use-able.


=== EDNS(0) ===

Implement EDNS specific record, message, protocol, client and server APIs and
switch the twistd dns server plugin to use them.

Deprecate the original non-EDNS aware versions of these.

Here are the steps:

==== [ticket:6680 Add Authentic Data (AD) and Checking Disabled (CD) flags] ====

Add two new fields to the existing dns.Message class
 * https://tools.ietf.org/html/rfc2535#section-6.1

Requirements:
 1. Set / get AD and CD field
 2. Byte encode / decode AD and CD field



==== [ticket:5668 dns.OPTHeader] ====

Parse and construct OPT Pseudo-RR
 * http://tools.ietf.org/html/rfc6891#section-6

Requirements:
 1. Get / set fixed OPT record fields.
 2. Byte encode / decode EDNS OPT records.
 3. Convert to / from dns.RRHeader (the existing non-EDNS record header class)
 4. Get / set variable OPT record fields.
 5. Byte encode / decode variable OPT record fields.
 6. Convert to / from dns.UnknownRecord (the existing non-EDNS record payload
    class for the unknown record payload types.)



==== [ticket:5675 dns.EDNSMessage] ====

Parse and construct EDNS messages
 * http://tools.ietf.org/html/rfc6891#section-4

Requirements:
 1. Get / set all non-EDNS message fields
    * https://tools.ietf.org/html/rfc1035#section-4
 2. Get / set all new EDNS(0) message fields
 3. Byte encoding / decoding
    1. During encoding, EDNS specific fields will be used to generate a
       dns.OPTHeader instance which will be added to the end of the additional
       records list.
    2. During decoding, an OPT pseudo record found in the additional section
       will be extracted, parsed and its fields will be used to populate the
       EDNS specific attributes of the EDNSMessage instance.
 4. Get / set extended RCODE
 5. A mechanism for getting protocol errors encountered during parsing. eg
    * "If a query message with more than one OPT RR is received, a FORMERR
      (RCODE=1) MUST be returned"
    * http://tools.ietf.org/html/rfc6891#section-6.1.1
 6. Convert to / from dns.Message (the existing non-EDNS message class)

Exclusions:
 1. We will not implement an API for manipulating OPT variable fields at this
    stage. See "Variable EDNS0 Option Codes" below.



==== dns.EDNSStreamProtocol and dns.EDNSDatagramProtcol or Message override options ====

The existing dns.DNSDatagramProtocol and DNSProtocol (TCP) are hardcoded to use
dns.Message for decoding and encoding wire messages.

The simplest solution would be to add a new "messageFactory" constructor
argument which allows us to supply a curried dns.EDNSMessage instance whose EDNS
specific constructor arguments have been preassigned.

Alternatively it might be better to introduce new narrower EDNS Protocol APIs
which wrap DNSProtocol, and DNSDatagramProtocol and hide many of their ugly
implementation details.

The wrappers can override the "writeMessage" method of the original protocols as
demonstrated here:
 * https://twistedmatrix.com/trac/browser/branches/edns-message-5675-4/twisted/names/edns.py?rev=39745

Requirements:
 1. DNS datagram and stream protocol implementations which can use
    dns.EDNSMessage for decoding and encoding wire messages.
 2. Get / set EDNS specific options which will be passed to the construct the
    EDNSMessage instance responsible for encoding and decoding.



==== client.Resolver protocol override options ====

client.Resolver is currently hard coded to use dns.DNSDatagramProtocol and
dns.DNSProtocol (TCP) via client.DNSClientFactory.

Allow the caller to supply alternative protocol factories.

Requirements:
 1. client.Resolver constructor will accept a "datagramProtocolFactory" and
    "streamProtocolFactory" arguments, which will default to existing factories
    but which will allow dns.EDNSDatagramProtocol to be supplied instead.



==== [ticket:5670 client.EDNSResolver Fixed UDP Payload Size] ====

Start with a basic EDNSResolver with a fixed UDP payload size and which only
does TCP fallback.
 * http://tools.ietf.org/html/rfc6891#section-6.2.2

Prerequisites:
 1. client.Resolver constructor will accept a "protocolFactory" argument, which
    will default to dns.Message but which will allow dns.EDNSMessage (or a
    factory function) to be supplied instead (break out into separate ticket)

Requirements:
 1. An implementation of t.i.interfaces.IResolver which sends EDNS(0) queries by
    default.
    * Wraps client.Resolver
    * Supplies an EDNSMessage factory to allow setting EDNS specific fields for
      all queries.
 2. Get / set AD, CD
 3. Get / set DO field. Default to "unset"
 4. Get / set VERSION. Default to 0.
 5. Get / set maximum UDP payload size.
    * Default to 4096
    * http://tools.ietf.org/html/rfc6891#section-6.2.5
 6. Detect servers which do not support EDNS(0) and fall back.
    1. ONLY fallback if DO is "unset"
    2. non-EDNS UDP query
    3. TCP query

Exclusions:
 1. We will not implement an API for manipulating OPT variable fields at this
    stage. See "Variable EDNS0 Option Codes" below.



==== client.EDNSResolver with Automatic Payload Size Selection and Detection  ====

Extend client.EDNSResolver to detect timeouts and fragmentation caused by UDP
payload size limits of the server and intermediate devices. Automatically
re-issue with successively smaller advertised payload sizes, possibly starting
with the server advertised payload size found in the first reply.

Consider postponing this. It's probably not required for basic DNSSEC client
support.

"A requestor MAY choose to implement a fallback to smaller advertised sizes to
work around firewall or other network limitations."
 * http://tools.ietf.org/html/rfc6891#section-6.2.5

Requirements:
 1. Issue parallel queries with a small delay between each and with successively
    smaller advertised UDP payload sizes.
 2. Cache and re-use the detected maximum payload size for each server.
 3. Fallback to TCP query.

Discussion:
 1. "Due to transaction overhead, it is not recommended to advertise an
    architectural limit as a maximum UDP payload size"
 2. "Values of less than 512 bytes MUST be treated as equal to 512 bytes."



==== [ticket:5669 server.EDNSServerFactory] ====

server.DNSServerFactory is responsible for coordinating datagram and stream
listening ports and their protocols.

The protocols dispatch their received queries to DNSServerFactory and it in turn
dispatches the queries to one or more authoritative, caching or recursive
IResolver instances.

It then constructs a response message, populates the answers, authority and
additional lists and supplies it to the write method of the appropriate protocol
instance.

DNSServerFactory is also responsible for enforcing policy, such as checking the
origin of queries or notify messages.

One problem with the existing implementation is that it uses the incoming
message and modifies it in place before sending it back to the client. This
results in various request fields being returned to the client as if they are
the server's chosen response fields.

This is completely wrong for the EDNS payload size and the new AD and CD fields.

A related problem is that it also includes the client's original OPT record in
error responses #6645

So here we will implement an EDNSServerFactory somehow overrides the
"messageReceived" method in order to enforce correct server max UDP payload
size.

Instead of re-using the incoming message instance, we will instead construct a
new instance and carefully choose the field values based on the servers
configuration.

 * http://tools.ietf.org/html/rfc6891#section-7

Requirements:
 1. Get / set maximum UDP payload size.
 2. Send EDNS0 responses to EDNS0 queries
 3. Do not send EDNS0 responses to standard DNS queries.
 4. Respond clients using their advertised UDP payload size. (up to the server
    maximum).
 5. Limit additional RRSETs so that responses fit the client max UDP payload
    size or mark response Messages truncated.
 6. Set extended EDNS RCODEs in responses where appropriate.



==== twistd dns plugin - EDNS(0) by default ====

At this point we should have enough infrastructure to allow the twistd dns
plugin to correctly respond to EDNS(0) queries.

If configured as a forwarding resolver, it will be able to issue EDNS(0) queries
to the upstream servers.

For compatibility we may choose to make it respond to clients with non-DNS
messages, but using the new EDNSMessage API.

Then at a later date we can add an --edns flag to allow the EDNS features to be
turned on or off. Or we could do it all in this ticket.

This isn't strictly needed for the goal of having a DNSSEC validating client,
but it will be a nice way in which Twisted users can quickly benefit from the
new EDNS APIs.



==== Variable EDNS0 Option Codes (OPT) ====

An OPT record payload can contain one or more variable fields. The list of
defined fields is here:
 * https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-11

One example is the EDNS(0) owner option which allows a DNS proxy (recursive or
forwarding resolver) to include information about the origin of the client query
(the client subnet), when it queries an authoritative server. An authoritative
server can use this information to do DNS based global load balancing.
 * http://tools.ietf.org/html/draft-cheshire-edns0-owner-option-00

Each of these variable fields would need it's own API so we need to give thought
to how the EDNSResolver can be made extensible enough to support these.



=== RRSET improvements ===

DNSSEC seems to rely on stable RRSETs. eg for signatures, for
predictable caching of records and signatures, for predictable
truncation of large DNSSEC responses.

There appear to be various problems with twisted.names current
handling of RRSETs.



==== Canonical Form and Order of Resource Records ====

https://tools.ietf.org/html/rfc4034#section-6

RRSETs must be arranged in canonical order before their signatures are
calculated / verified.

This ticket will introduce an algorithm for sorting records
according to the rules described in
https://tools.ietf.org/html/rfc4034#section-6.

Sorting appears to be the responsibility of the verifying client
not the server.

The fact that Bind has config options for changing the order of
RRSETS on the server side and the client side suggests that the
canonical ordering of records should be done only for the purpose
of DNSSEC validation. It should probably not change the order of
records returned by various IResolver methods.

 * http://www.zytrax.com/books/dns/ch7/queries.html#rrset-order



==== Serving RRSETs ====

twisted.names.dns.Message should follow the guidance in RFC2181
regarding the handling of TTLs for records in the same
RRSET. Alternatively consider handling this higher up in
t.n.authority.FileAuthority, t.n.cache, t.n.resolver etc.

 * https://tools.ietf.org/html/rfc2181#section-5
 * https://tools.ietf.org/html/rfc2181#section-5.2
 * "the use of differing TTLs in an RRSet is hereby deprecated,
   the TTLs of all RRs in an RRSet must be the same"
 * "In no case may a server send an RRSet with TTLs not all
   equal."
 * https://tools.ietf.org/html/rfc2181#section-5.5
 * "A Resource Record Set should only be included once in any DNS
   reply.  It may occur in any of the Answer, Authority, or
   Additional Information sections, as required.  However it
   should not be repeated in the same, or any other, section,
   except where explicitly required by a specification."



==== Receiving RRSETs ====

twisted.names.client should somehow signal an error if it receives
RRSETs whose RRs have different TTLs.

twisted.names.resolver,root should discard RRSETs whose RRs have
diffent TTLs.

 * https://tools.ietf.org/html/rfc2181#section-5.2
 * "Should a client receive a response containing RRs from an
   RRSet with differing TTLs, it should treat this as an error.
   If the RRSet concerned is from a non-authoritative source for
   this data, the client should simply ignore the RRSet,"



==== Caching RRSETs ====

twisted.names.cache should follow the RRSET ranking guidance when
serving and replacing items in its cache.

 * https://tools.ietf.org/html/rfc2181#section-5.4
 * "Servers must never merge RRs from a response with RRs in their
   cache to form an RRSet.  If a response contains data that would
   form an RRSet with data in a server's cache the server must
   either ignore the RRs in the response, or discard the entire
   RRSet currently in the cache, as appropriate."
 * https://tools.ietf.org/html/rfc2181#section-5.4.1
 * "When considering whether to accept an RRSet in a reply, or
   retain an RRSet already in its cache instead, a server should
   consider the relative likely trustworthiness of the various
   data"



==== Selective truncate ====

twisted.names.dns.Message currently truncates messages based on the
combined length of the answer, auth, and additional sections. Instead
it (or something higher up) should look at the length of the answers
and only set the truncate flag if the entire answers RRSET is greater
than the maxPayloadSize. If there is room, the auth and additional
records can also be included, but entire RRSETs must be included or
none.

 * https://tools.ietf.org/html/rfc2181#section-9
 * "The TC bit should be set in responses only when an RRSet is
   required as a part of the response, but could not be included
   in its entirety."



=== DNSSEC ===

Much of this work (including tests) has already been implemented by
BobNovas in two large patches attached to original
tickets: #5450, #5453, #5454. Look there before implementing anything
from scratch.



==== New DNSSEC Records and Lookup Methods ====
 1. DNSSEC introduces six new resource record types. Each new record
    type will require a new dns.Record subclass and a new lookupMethod
    added to t.i.interfaces.IResolver, t.n.common.ResolverBase and a
    corresponding free function in t.n.client.
    1. #6664 DNSKey
       https://tools.ietf.org/html/rfc4034#section-2
    2. #6665 RRSIG
       https://tools.ietf.org/html/rfc4034#section-3
    3. NSEC
       https://tools.ietf.org/html/rfc4034#section-4
    4. DS
       https://tools.ietf.org/html/rfc4034#section-5
    5. NSEC3
       https://tools.ietf.org/html/rfc5155#section-3
    6. NSEC3Param
       https://tools.ietf.org/html/rfc5155#section-4
 2. For ease of review, this work can be split into six tickets.
 3. These new records can be implemented independently of EDNS and
    independently of DNSSEC validation and new DNSSEC related message
    headers.
 4. Initially, this will allow twisted.names clients to explicitly
    request these DNSSEC related records.
 5. lookupZone will return DNSSEC related records when transferring
    from DNSSEC authoritative servers.
 6. t.n.secondary.SecondaryAuthority will download DNSSEC records and
    serve them when queries specifically ask for them by type.
 7. t.n.authority.FileAuthority will load DNSSEC records and serve
    them when queries specifically ask for them by type.



==== Security-aware Non-validating Client ====

A twisted.names.client will be able to generate EDNS queries with one
or both the DO bit and the AD bit set.

It will examine the state of the AD bit in the response to determine
whether the upstream resolver claims to have validated the records in
the response.

If the DO bit was set, it will expect to receive DNSSEC related
records in the response.

https://tools.ietf.org/html/rfc4035#section-4.9



==== Validating Client ====

A twisted.names.client which sends DO + CD flagged queries and
performs its own validation of the returned DNSSEC signatures.

TODO: needs more thought.



==== Validating Recursive / Forwarding Server ====

This can use the Validating client API above, but may need to do some
processing of answers based on the query flags.

TODO: needs more thought.



==== DNSSEC Aware Authoritative Server ====

A twisted.names.authority API which knows where and when to include
RRSIG, DNSKEY, NSEC, NSEC3 records etc with responses.

The actual generation of the DNSSEC records can be performed using
external tools such as
[http://linux.die.net/man/8/dnssec-signzone dnssec-signzone]

TODO: needs more thought.



== RFCs ==

=== General ===
 1. [https://tools.ietf.org/html/rfc1034 1034:DOMAIN NAMES - CONCEPTS AND FACILITIES]
 2. [https://tools.ietf.org/html/rfc1035 1035: DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION]
 3. [https://tools.ietf.org/html/rfc2181 2181: Clarifications to the DNS Specification]
 4. [https://tools.ietf.org/html/rfc4697 4697: Observed DNS Resolution Misbehavior]
 5. [https://tools.ietf.org/html/rfc5625 5625: DNS Proxy Implementation Guidelines]

=== EDNS ===
 1. [http://tools.ietf.org/html/rfc6891 6891: Extension Mechanisms for DNS (EDNS(0))]

=== DNSSEC ===
 1. [https://tools.ietf.org/html/rfc4033 4033: DNS Security Introduction and Requirements]
 2. [https://tools.ietf.org/html/rfc4034 4034: Resource Records for the DNS Security Extensions]
 3. [https://tools.ietf.org/html/rfc4035 4035: Protocol Modifications for the DNS Security Extensions]
 4. [https://tools.ietf.org/html/rfc5155 5155: DNS Security (DNSSEC) Hashed Authenticated Denial of Existence]
 5. [https://tools.ietf.org/html/rfc6781 6781: DNSSEC Operational Practices, Version 2]
 6. [https://tools.ietf.org/html/rfc6840 6840: Clarifications and Implementation Notes for DNS Security (DNSSEC)]
 7. [https://tools.ietf.org/html/rfc3833 3833: Threat Analysis of the Domain Name System (DNS)]
